import { WhamoNode, WhamoEdge } from './store';
import { saveAs } from 'file-saver';

export function generateInpFile(nodes: WhamoNode[], edges: WhamoEdge[]) {
  const lines: string[] = [];

  // Helper to add line
  const add = (str: string) => lines.push(str);

  // 1. Header / Comments
  add('Generated by WHAMO Web Designer');
  add('REMARK -------------------------------------------------------------------------');
  add('');

  // 2. SYSTEM Block (Topology)
  add('SYSTEM');

  // Reservoirs
  nodes.filter(n => n.type === 'reservoir').forEach(n => {
    add(`ELEM ${n.data.label} AT ${n.data.nodeNumber || n.id}  ; Reservoir`);
  });

  // Surge Tanks
  nodes.filter(n => n.type === 'surgeTank').forEach(n => {
    add(`ELEM ${n.data.label} AT ${n.data.nodeNumber}  ; Surge Tank`);
  });

  // Flow Boundaries
  nodes.filter(n => n.type === 'flowBoundary').forEach(n => {
    add(`ELEM ${n.data.label} AT ${n.data.nodeNumber}  ; Flow Boundary`);
  });

  // Conduits / Dummy Pipes (Edges)
  edges.forEach(e => {
    const fromNode = nodes.find(n => n.id === e.source);
    const toNode = nodes.find(n => n.id === e.target);
    const fromId = fromNode?.data.nodeNumber || fromNode?.id || e.source;
    const toId = toNode?.data.nodeNumber || toNode?.id || e.target;
    add(`ELEM ${e.data?.label || e.id} LINK ${fromId} ${toId}  ; ${e.type === 'dummy' ? 'Dummy' : 'Conduit'}`);
  });

  // Junctions - defined purely as topology points in WHAMO usually, but if explicit junction elements needed:
  nodes.filter(n => n.type === 'junction').forEach(n => {
    add(`JUNCTION AT ${n.data.nodeNumber}`);
  });

  add('FINISH');
  add('');

  // 3. NODE ELEVATIONS
  add('NODE');
  nodes.forEach(n => {
    // Only output if elevation is defined
    if (n.data.elevation !== undefined) {
      add(`${n.data.nodeNumber || n.id} ELEV ${n.data.elevation}`);
    }
  });
  add('FINISH');
  add('');

  // 4. ELEMENT PROPERTIES
  // Reservoirs
  nodes.filter(n => n.type === 'reservoir').forEach(n => {
    add(`RESERVOIR ID ${n.data.label} ELEV ${n.data.elevation} FINISH`);
  });

  // Conduits
  edges.filter(e => e.type === 'conduit').forEach(e => {
    const d = e.data;
    if (d) {
      add(`CONDUIT ID ${d.label || e.id} LENG ${d.length} DIAM ${d.diameter} CELE ${d.celerity} FRIC ${d.friction} NUMSEG ${d.numSegments} FINISH`);
    }
  });

  // Dummy Pipes
  edges.filter(e => e.type === 'dummy').forEach(e => {
    const d = e.data;
    if (d) {
      add(`CONDUIT ID ${d.label || e.id} DUMMY DIAMETER ${d.diameter} ADDEDLOSS CPLUS ${d.cplus || 0} CMINUS ${d.cminus || 0} FINISH`);
    }
  });

  // Surge Tanks
  nodes.filter(n => n.type === 'surgeTank').forEach(n => {
    const d = n.data;
    add(`SURGETANK ID ${d.label} SIMPLE ELTOP ${d.topElevation} ELBOTTOM ${d.bottomElevation} DIAM ${d.diameter} CELERITY ${d.celerity} FRICTION ${d.friction} FINISH`);
  });

  // Flow Boundaries
  nodes.filter(n => n.type === 'flowBoundary').forEach(n => {
    const d = n.data;
    add(`FLOWBC ID ${d.label} QSCHEDULE ${d.scheduleNumber} FINISH`);
  });

  add('');
  add('OUTPUT');
  add('  SNAPSHOT ALL');
  add('  HISTORY NODE ALL');
  add('FINISH');
  add('');
  add('EXECUTION');
  add('  TIME 20.0');
  add('  DT 0.01');
  add('FINISH');

  const blob = new Blob([lines.join('\n')], { type: 'text/plain;charset=utf-8' });
  saveAs(blob, `network_${Date.now()}.inp`);
}
